//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl ?? '';
  }

  /**
   * @return Success
   */
  areasGET(): Promise<void> {
    let url_ = this.baseUrl + '/api/Areas';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAreasGET(_response);
    });
  }

  protected processAreasGET(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  areasPOST(body: Area | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Areas';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAreasPOST(_response);
    });
  }

  protected processAreasPOST(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  areasGET2(areaId: string): Promise<void> {
    let url_ = this.baseUrl + '/api/Areas/{areaId}';
    if (areaId === undefined || areaId === null)
      throw new Error("The parameter 'areaId' must be defined.");
    url_ = url_.replace('{areaId}', encodeURIComponent('' + areaId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAreasGET2(_response);
    });
  }

  protected processAreasGET2(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  areasPUT(areaId: string, body: Area | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Areas/{areaId}';
    if (areaId === undefined || areaId === null)
      throw new Error("The parameter 'areaId' must be defined.");
    url_ = url_.replace('{areaId}', encodeURIComponent('' + areaId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAreasPUT(_response);
    });
  }

  protected processAreasPUT(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  areasDELETE(areaId: string): Promise<void> {
    let url_ = this.baseUrl + '/api/Areas/{areaId}';
    if (areaId === undefined || areaId === null)
      throw new Error("The parameter 'areaId' must be defined.");
    url_ = url_.replace('{areaId}', encodeURIComponent('' + areaId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'DELETE',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processAreasDELETE(_response);
    });
  }

  protected processAreasDELETE(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  locationsGET(): Promise<void> {
    let url_ = this.baseUrl + '/api/Locations';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLocationsGET(_response);
    });
  }

  protected processLocationsGET(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  locationsPOST(body: Location | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Locations';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLocationsPOST(_response);
    });
  }

  protected processLocationsPOST(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  locationsGET2(locationId: string): Promise<void> {
    let url_ = this.baseUrl + '/api/Locations/{locationId}';
    if (locationId === undefined || locationId === null)
      throw new Error("The parameter 'locationId' must be defined.");
    url_ = url_.replace('{locationId}', encodeURIComponent('' + locationId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLocationsGET2(_response);
    });
  }

  protected processLocationsGET2(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  locationsPUT(locationId: string, body: Location | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Locations/{locationId}';
    if (locationId === undefined || locationId === null)
      throw new Error("The parameter 'locationId' must be defined.");
    url_ = url_.replace('{locationId}', encodeURIComponent('' + locationId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLocationsPUT(_response);
    });
  }

  protected processLocationsPUT(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  locationsDELETE(locationId: string): Promise<void> {
    let url_ = this.baseUrl + '/api/Locations/{locationId}';
    if (locationId === undefined || locationId === null)
      throw new Error("The parameter 'locationId' must be defined.");
    url_ = url_.replace('{locationId}', encodeURIComponent('' + locationId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'DELETE',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLocationsDELETE(_response);
    });
  }

  protected processLocationsDELETE(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  machinesGET(): Promise<void> {
    let url_ = this.baseUrl + '/api/Machines';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processMachinesGET(_response);
    });
  }

  protected processMachinesGET(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  machinesPOST(body: Machine | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Machines';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processMachinesPOST(_response);
    });
  }

  protected processMachinesPOST(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  machinesGET2(machineId: string): Promise<void> {
    let url_ = this.baseUrl + '/api/Machines/{machineId}';
    if (machineId === undefined || machineId === null)
      throw new Error("The parameter 'machineId' must be defined.");
    url_ = url_.replace('{machineId}', encodeURIComponent('' + machineId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processMachinesGET2(_response);
    });
  }

  protected processMachinesGET2(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  machinesPUT(machineId: string, body: Machine | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Machines/{machineId}';
    if (machineId === undefined || machineId === null)
      throw new Error("The parameter 'machineId' must be defined.");
    url_ = url_.replace('{machineId}', encodeURIComponent('' + machineId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processMachinesPUT(_response);
    });
  }

  protected processMachinesPUT(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  machinesDELETE(machineId: string): Promise<void> {
    let url_ = this.baseUrl + '/api/Machines/{machineId}';
    if (machineId === undefined || machineId === null)
      throw new Error("The parameter 'machineId' must be defined.");
    url_ = url_.replace('{machineId}', encodeURIComponent('' + machineId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'DELETE',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processMachinesDELETE(_response);
    });
  }

  protected processMachinesDELETE(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  ordersGET(): Promise<void> {
    let url_ = this.baseUrl + '/api/Orders';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processOrdersGET(_response);
    });
  }

  protected processOrdersGET(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  ordersPOST(body: Order | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Orders';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processOrdersPOST(_response);
    });
  }

  protected processOrdersPOST(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  ordersGET2(orderId: string): Promise<void> {
    let url_ = this.baseUrl + '/api/Orders/{orderId}';
    if (orderId === undefined || orderId === null)
      throw new Error("The parameter 'orderId' must be defined.");
    url_ = url_.replace('{orderId}', encodeURIComponent('' + orderId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processOrdersGET2(_response);
    });
  }

  protected processOrdersGET2(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  ordersPUT(orderId: string, body: Order | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Orders/{orderId}';
    if (orderId === undefined || orderId === null)
      throw new Error("The parameter 'orderId' must be defined.");
    url_ = url_.replace('{orderId}', encodeURIComponent('' + orderId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processOrdersPUT(_response);
    });
  }

  protected processOrdersPUT(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  ordersDELETE(orderId: string): Promise<void> {
    let url_ = this.baseUrl + '/api/Orders/{orderId}';
    if (orderId === undefined || orderId === null)
      throw new Error("The parameter 'orderId' must be defined.");
    url_ = url_.replace('{orderId}', encodeURIComponent('' + orderId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'DELETE',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processOrdersDELETE(_response);
    });
  }

  protected processOrdersDELETE(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  rollsOfSteelGET(): Promise<void> {
    let url_ = this.baseUrl + '/api/RollsOfSteel';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRollsOfSteelGET(_response);
    });
  }

  protected processRollsOfSteelGET(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  rollsOfSteelPOST(body: RollOfSteel | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/RollsOfSteel';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRollsOfSteelPOST(_response);
    });
  }

  protected processRollsOfSteelPOST(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  rollsOfSteelGET2(rollOfSteelId: string): Promise<void> {
    let url_ = this.baseUrl + '/api/RollsOfSteel/{rollOfSteelId}';
    if (rollOfSteelId === undefined || rollOfSteelId === null)
      throw new Error("The parameter 'rollOfSteelId' must be defined.");
    url_ = url_.replace(
      '{rollOfSteelId}',
      encodeURIComponent('' + rollOfSteelId),
    );
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRollsOfSteelGET2(_response);
    });
  }

  protected processRollsOfSteelGET2(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  rollsOfSteelPUT(
    rollOfSteelId: string,
    body: RollOfSteel | undefined,
  ): Promise<void> {
    let url_ = this.baseUrl + '/api/RollsOfSteel/{rollOfSteelId}';
    if (rollOfSteelId === undefined || rollOfSteelId === null)
      throw new Error("The parameter 'rollOfSteelId' must be defined.");
    url_ = url_.replace(
      '{rollOfSteelId}',
      encodeURIComponent('' + rollOfSteelId),
    );
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRollsOfSteelPUT(_response);
    });
  }

  protected processRollsOfSteelPUT(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  rollsOfSteelDELETE(rollOfSteelId: string): Promise<void> {
    let url_ = this.baseUrl + '/api/RollsOfSteel/{rollOfSteelId}';
    if (rollOfSteelId === undefined || rollOfSteelId === null)
      throw new Error("The parameter 'rollOfSteelId' must be defined.");
    url_ = url_.replace(
      '{rollOfSteelId}',
      encodeURIComponent('' + rollOfSteelId),
    );
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'DELETE',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRollsOfSteelDELETE(_response);
    });
  }

  protected processRollsOfSteelDELETE(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  trucksGET(): Promise<void> {
    let url_ = this.baseUrl + '/api/Trucks';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processTrucksGET(_response);
    });
  }

  protected processTrucksGET(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  trucksPOST(body: Truck | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Trucks';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processTrucksPOST(_response);
    });
  }

  protected processTrucksPOST(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  trucksGET2(truckId: string): Promise<void> {
    let url_ = this.baseUrl + '/api/Trucks/{truckId}';
    if (truckId === undefined || truckId === null)
      throw new Error("The parameter 'truckId' must be defined.");
    url_ = url_.replace('{truckId}', encodeURIComponent('' + truckId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processTrucksGET2(_response);
    });
  }

  protected processTrucksGET2(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  trucksPUT(truckId: string, body: Truck | undefined): Promise<void> {
    let url_ = this.baseUrl + '/api/Trucks/{truckId}';
    if (truckId === undefined || truckId === null)
      throw new Error("The parameter 'truckId' must be defined.");
    url_ = url_.replace('{truckId}', encodeURIComponent('' + truckId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processTrucksPUT(_response);
    });
  }

  protected processTrucksPUT(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  trucksDELETE(truckId: string): Promise<void> {
    let url_ = this.baseUrl + '/api/Trucks/{truckId}';
    if (truckId === undefined || truckId === null)
      throw new Error("The parameter 'truckId' must be defined.");
    url_ = url_.replace('{truckId}', encodeURIComponent('' + truckId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'DELETE',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processTrucksDELETE(_response);
    });
  }

  protected processTrucksDELETE(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  usersPOST(body: User | undefined): Promise<void> {
    let url_ = this.baseUrl + '/Users';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUsersPOST(_response);
    });
  }

  protected processUsersPOST(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  usersGET(): Promise<void> {
    let url_ = this.baseUrl + '/Users';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUsersGET(_response);
    });
  }

  protected processUsersGET(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  usersGET2(userId: string): Promise<void> {
    let url_ = this.baseUrl + '/Users/{userId}';
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUsersGET2(_response);
    });
  }

  protected processUsersGET2(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  usersPUT(userId: string, body: User | undefined): Promise<void> {
    let url_ = this.baseUrl + '/Users/{userId}';
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUsersPUT(_response);
    });
  }

  protected processUsersPUT(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  usersDELETE(userId: string): Promise<void> {
    let url_ = this.baseUrl + '/Users/{userId}';
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'DELETE',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUsersDELETE(_response);
    });
  }

  protected processUsersDELETE(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  login(body: User | undefined): Promise<void> {
    let url_ = this.baseUrl + '/Users/login';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: RequestInit = {
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLogin(_response);
    });
  }

  protected processLogin(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }
}

export class Area implements IArea {
  areaId?: string | undefined;
  name?: string | undefined;
  locationIds?: string[] | undefined;
  trucks?: Truck[] | undefined;
  locations?: Location[] | undefined;

  constructor(data?: IArea) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.areaId = _data['areaId'];
      this.name = _data['name'];
      if (Array.isArray(_data['locationIds'])) {
        this.locationIds = [] as any;
        for (let item of _data['locationIds']) this.locationIds!.push(item);
      }
      if (Array.isArray(_data['trucks'])) {
        this.trucks = [] as any;
        for (let item of _data['trucks']) this.trucks!.push(Truck.fromJS(item));
      }
      if (Array.isArray(_data['locations'])) {
        this.locations = [] as any;
        for (let item of _data['locations'])
          this.locations!.push(Location.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Area {
    data = typeof data === 'object' ? data : {};
    let result = new Area();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['areaId'] = this.areaId;
    data['name'] = this.name;
    if (Array.isArray(this.locationIds)) {
      data['locationIds'] = [];
      for (let item of this.locationIds) data['locationIds'].push(item);
    }
    if (Array.isArray(this.trucks)) {
      data['trucks'] = [];
      for (let item of this.trucks) data['trucks'].push(item.toJSON());
    }
    if (Array.isArray(this.locations)) {
      data['locations'] = [];
      for (let item of this.locations) data['locations'].push(item.toJSON());
    }
    return data;
  }
}

export interface IArea {
  areaId?: string | undefined;
  name?: string | undefined;
  locationIds?: string[] | undefined;
  trucks?: Truck[] | undefined;
  locations?: Location[] | undefined;
}

export class Location implements ILocation {
  locationId?: string | undefined;
  areaId?: string | undefined;
  capacity?: number;
  currentOccupancy?: number;
  area?: Area;

  constructor(data?: ILocation) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.locationId = _data['locationId'];
      this.areaId = _data['areaId'];
      this.capacity = _data['capacity'];
      this.currentOccupancy = _data['currentOccupancy'];
      this.area = _data['area'] ? Area.fromJS(_data['area']) : <any>undefined;
    }
  }

  static fromJS(data: any): Location {
    data = typeof data === 'object' ? data : {};
    let result = new Location();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['locationId'] = this.locationId;
    data['areaId'] = this.areaId;
    data['capacity'] = this.capacity;
    data['currentOccupancy'] = this.currentOccupancy;
    data['area'] = this.area ? this.area.toJSON() : <any>undefined;
    return data;
  }
}

export interface ILocation {
  locationId?: string | undefined;
  areaId?: string | undefined;
  capacity?: number;
  currentOccupancy?: number;
  area?: Area;
}

export class Machine implements IMachine {
  machineId?: string | undefined;
  type?: string | undefined;
  locationId?: string | undefined;
  status?: string | undefined;

  constructor(data?: IMachine) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.machineId = _data['machineId'];
      this.type = _data['type'];
      this.locationId = _data['locationId'];
      this.status = _data['status'];
    }
  }

  static fromJS(data: any): Machine {
    data = typeof data === 'object' ? data : {};
    let result = new Machine();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['machineId'] = this.machineId;
    data['type'] = this.type;
    data['locationId'] = this.locationId;
    data['status'] = this.status;
    return data;
  }
}

export interface IMachine {
  machineId?: string | undefined;
  type?: string | undefined;
  locationId?: string | undefined;
  status?: string | undefined;
}

export class Order implements IOrder {
  orderId?: string | undefined;
  type?: string | undefined;
  status?: string | undefined;
  associatedRollsIds?: string[] | undefined;
  sourceLocation?: Location;
  destinationLocation?: Location;
  orderRollsOfSteel?: OrderRollOfSteel[] | undefined;

  constructor(data?: IOrder) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.orderId = _data['orderId'];
      this.type = _data['type'];
      this.status = _data['status'];
      if (Array.isArray(_data['associatedRollsIds'])) {
        this.associatedRollsIds = [] as any;
        for (let item of _data['associatedRollsIds'])
          this.associatedRollsIds!.push(item);
      }
      this.sourceLocation = _data['sourceLocation']
        ? Location.fromJS(_data['sourceLocation'])
        : <any>undefined;
      this.destinationLocation = _data['destinationLocation']
        ? Location.fromJS(_data['destinationLocation'])
        : <any>undefined;
      if (Array.isArray(_data['orderRollsOfSteel'])) {
        this.orderRollsOfSteel = [] as any;
        for (let item of _data['orderRollsOfSteel'])
          this.orderRollsOfSteel!.push(OrderRollOfSteel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Order {
    data = typeof data === 'object' ? data : {};
    let result = new Order();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['orderId'] = this.orderId;
    data['type'] = this.type;
    data['status'] = this.status;
    if (Array.isArray(this.associatedRollsIds)) {
      data['associatedRollsIds'] = [];
      for (let item of this.associatedRollsIds)
        data['associatedRollsIds'].push(item);
    }
    data['sourceLocation'] = this.sourceLocation
      ? this.sourceLocation.toJSON()
      : <any>undefined;
    data['destinationLocation'] = this.destinationLocation
      ? this.destinationLocation.toJSON()
      : <any>undefined;
    if (Array.isArray(this.orderRollsOfSteel)) {
      data['orderRollsOfSteel'] = [];
      for (let item of this.orderRollsOfSteel)
        data['orderRollsOfSteel'].push(item.toJSON());
    }
    return data;
  }
}

export interface IOrder {
  orderId?: string | undefined;
  type?: string | undefined;
  status?: string | undefined;
  associatedRollsIds?: string[] | undefined;
  sourceLocation?: Location;
  destinationLocation?: Location;
  orderRollsOfSteel?: OrderRollOfSteel[] | undefined;
}

export class OrderRollOfSteel implements IOrderRollOfSteel {
  orderId?: string | undefined;
  order?: Order;
  rollOfSteelId?: string | undefined;
  rollOfSteel?: RollOfSteel;
  orderRollsOfSteel?: OrderRollOfSteel[] | undefined;

  constructor(data?: IOrderRollOfSteel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.orderId = _data['orderId'];
      this.order = _data['order']
        ? Order.fromJS(_data['order'])
        : <any>undefined;
      this.rollOfSteelId = _data['rollOfSteelId'];
      this.rollOfSteel = _data['rollOfSteel']
        ? RollOfSteel.fromJS(_data['rollOfSteel'])
        : <any>undefined;
      if (Array.isArray(_data['orderRollsOfSteel'])) {
        this.orderRollsOfSteel = [] as any;
        for (let item of _data['orderRollsOfSteel'])
          this.orderRollsOfSteel!.push(OrderRollOfSteel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): OrderRollOfSteel {
    data = typeof data === 'object' ? data : {};
    let result = new OrderRollOfSteel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['orderId'] = this.orderId;
    data['order'] = this.order ? this.order.toJSON() : <any>undefined;
    data['rollOfSteelId'] = this.rollOfSteelId;
    data['rollOfSteel'] = this.rollOfSteel
      ? this.rollOfSteel.toJSON()
      : <any>undefined;
    if (Array.isArray(this.orderRollsOfSteel)) {
      data['orderRollsOfSteel'] = [];
      for (let item of this.orderRollsOfSteel)
        data['orderRollsOfSteel'].push(item.toJSON());
    }
    return data;
  }
}

export interface IOrderRollOfSteel {
  orderId?: string | undefined;
  order?: Order;
  rollOfSteelId?: string | undefined;
  rollOfSteel?: RollOfSteel;
  orderRollsOfSteel?: OrderRollOfSteel[] | undefined;
}

export class RollOfSteel implements IRollOfSteel {
  rollOfSteelId?: string | undefined;
  status?: string | undefined;
  currentLocationId?: string | undefined;
  destinationLocationId?: string | undefined;
  orderRollsOfSteel?: OrderRollOfSteel[] | undefined;

  constructor(data?: IRollOfSteel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.rollOfSteelId = _data['rollOfSteelId'];
      this.status = _data['status'];
      this.currentLocationId = _data['currentLocationId'];
      this.destinationLocationId = _data['destinationLocationId'];
      if (Array.isArray(_data['orderRollsOfSteel'])) {
        this.orderRollsOfSteel = [] as any;
        for (let item of _data['orderRollsOfSteel'])
          this.orderRollsOfSteel!.push(OrderRollOfSteel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RollOfSteel {
    data = typeof data === 'object' ? data : {};
    let result = new RollOfSteel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['rollOfSteelId'] = this.rollOfSteelId;
    data['status'] = this.status;
    data['currentLocationId'] = this.currentLocationId;
    data['destinationLocationId'] = this.destinationLocationId;
    if (Array.isArray(this.orderRollsOfSteel)) {
      data['orderRollsOfSteel'] = [];
      for (let item of this.orderRollsOfSteel)
        data['orderRollsOfSteel'].push(item.toJSON());
    }
    return data;
  }
}

export interface IRollOfSteel {
  rollOfSteelId?: string | undefined;
  status?: string | undefined;
  currentLocationId?: string | undefined;
  destinationLocationId?: string | undefined;
  orderRollsOfSteel?: OrderRollOfSteel[] | undefined;
}

export class Truck implements ITruck {
  truckId?: string | undefined;
  currentAreaId?: string | undefined;
  status?: string | undefined;
  currentArea?: Area;

  constructor(data?: ITruck) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.truckId = _data['truckId'];
      this.currentAreaId = _data['currentAreaId'];
      this.status = _data['status'];
      this.currentArea = _data['currentArea']
        ? Area.fromJS(_data['currentArea'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): Truck {
    data = typeof data === 'object' ? data : {};
    let result = new Truck();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['truckId'] = this.truckId;
    data['currentAreaId'] = this.currentAreaId;
    data['status'] = this.status;
    data['currentArea'] = this.currentArea
      ? this.currentArea.toJSON()
      : <any>undefined;
    return data;
  }
}

export interface ITruck {
  truckId?: string | undefined;
  currentAreaId?: string | undefined;
  status?: string | undefined;
  currentArea?: Area;
}

export class User implements IUser {
  userId?: string | undefined;
  role?: UserRole;
  username?: string | undefined;
  passwordHash?: string | undefined;

  constructor(data?: IUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.role = _data['role'];
      this.username = _data['username'];
      this.passwordHash = _data['passwordHash'];
    }
  }

  static fromJS(data: any): User {
    data = typeof data === 'object' ? data : {};
    let result = new User();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['role'] = this.role;
    data['username'] = this.username;
    data['passwordHash'] = this.passwordHash;
    return data;
  }
}

export interface IUser {
  userId?: string | undefined;
  role?: UserRole;
  username?: string | undefined;
  passwordHash?: string | undefined;
}

export enum UserRole {
  Admin = 'Admin',
  User = 'User',
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any,
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any,
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}
